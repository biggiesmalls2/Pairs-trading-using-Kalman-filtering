# -*- coding: utf-8 -*-
"""Week 2: Applying Kalman Filter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DEsfN2yTG8TsH3PgaCA5f8IX7b5ZHYco
"""

!pip install pykalman
!pip install ffn

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib
import yfinance as yf
from pykalman import KalmanFilter
from datetime import datetime
from numpy import log, polyfit, sqrt, std, subtract
import statsmodels.tsa.stattools as ts
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
import ffn
import warnings
warnings.filterwarnings('ignore')
from itertools import product

start = datetime(2010, 1, 1)
end = datetime(2020, 1, 1)

tickers = ['ADBE','MSFT']

df = yf.download(tickers, start, end)['Close']
df = df.dropna()

ratio=df['ADBE']/df['MSFT']
train_test_ratio= round(len(ratio)*0.7)
print(train_test_ratio)

test_start= round(len(ratio)*0.7)
val_start= round(len(ratio)*0.9)
print(test_start)
print(val_start)
print(len(ratio))

train= ratio[:train_test_ratio]
test= ratio[train_test_ratio:val_start]
OS= ratio[val_start:]

x = df['ADBE']
y = df['MSFT']

train_x = x[:test_start]
train_y = y[:test_start]

test_x = x[test_start:val_start]
test_y = y[test_start:val_start]

val_x = x[val_start:]
val_y = y[val_start:]


plt.plot(train)
plt.show()

def KalmanFilterAverage(x):
    # Construct a Kalman filter
    kf = KalmanFilter(transition_matrices = [1],
                      observation_matrices = [1],
                      initial_state_mean = 0,
                      initial_state_covariance = 1,
                      observation_covariance=1,
                      transition_covariance=.01)

    # Use the observed values of the price to get a rolling mean
    state_means, _ = kf.filter(x.values)
    state_means = pd.Series(state_means.flatten(), index=x.index)
    return state_means

#--------------------------------------------------------------------------------------

#  Kalman filter regression
def KalmanFilterRegression(x,y):

    delta = 1e-3
    trans_cov = delta / (1 - delta) * np.eye(2) # How much random walk wiggles
    obs_mat = np.expand_dims(np.vstack([[x], [np.ones(len(x))]]).T, axis=1)

    kf = KalmanFilter(n_dim_obs=1, n_dim_state=2, # y is 1-dimensional, (alpha, beta) is 2-dimensional
                      initial_state_mean=[0,0],
                      initial_state_covariance=np.ones((2, 2)),
                      transition_matrices=np.eye(2),
                      observation_matrices=obs_mat,
                      observation_covariance=2,
                      transition_covariance=trans_cov)

    # Use the observations y to get running estimates and errors for the state parameters
    state_means, state_covs = kf.filter(y.values)
    return state_means

regression_results = KalmanFilterRegression(KalmanFilterAverage(x), KalmanFilterAverage(y))

a_estimate = regression_results[:, 0]  # Slope (alpha)
b_estimate = regression_results[:, 1]  # Intercept (beta)

# Print the last estimates for slope and intercept
print(f"Estimated slope (a): {a_estimate[-1]:.4f}")
print(f"Estimated intercept (b): {b_estimate[-1]:.4f}")

spread = y - (a_estimate + x*b_estimate)
spread_mean =  spread.mean()
spread_std = spread.std()

k=1
movavg=train.rolling(window=20, center= False).mean()

#calculating standard deviation (volatility)
std=train.rolling(window=20, center=False).std()

upper_band= movavg + (k*std)
lower_band= movavg - (k*std)

plt.figure(figsize=(12,7))
plt.plot(ratio, label='Ratio')
buy = train.copy()
sell = train.copy()
buy[train>lower_band] = 0
sell[train<upper_band] = 0

plt.figure(figsize=(12,7))
plt.plot(train, label='ratio')

buy.plot(color='g', linestyle='None', marker='^')
sell.plot(color='r', linestyle='None', marker='^')
x1, x2, y1, y2 = plt.axis()
plt.axis((x1, x2, ratio.min(), ratio.max()))
plt.xlim('2010-01-01','2017-01-01')
plt.legend(['Train', 'Buy Signal', 'Sell Signal'])
plt.show()

plt.figure(figsize=(12,7))
S1 = df['ADBE'].iloc[:1761]
S2 = df['MSFT'].iloc[:1761]

S1[60:].plot(color='b')
S2[60:].plot(color='c')
buyR = 0*S1.copy()
sellR = 0*S1.copy()

# When you buy the ratio, you buy stock S1 and sell S2
buyR[buy!=0] = S1[buy!=0]
sellR[buy!=0] = S2[buy!=0]

# When you sell the ratio, you sell stock S1 and buy S2
buyR[sell!=0] = S2[sell!=0]
sellR[sell!=0] = S1[sell!=0]

buyR[60:].plot(color='g', linestyle='None', marker='^')
sellR[60:].plot(color='r', linestyle='None', marker='^')
x1, x2, y1, y2 = plt.axis()
plt.axis((x1, x2, min(S1.min(), S2.min()), max(S1.max(), S2.max())))
plt.ylim(25, 105)
plt.xlim('2013-03-22', '2016-07-04')

plt.legend(['ADBE', 'MSFT', 'Buy Signal', 'Sell Signal'])
plt.show()

threshold = 0.8

def trade(S1, S2, window, k):
    if window == 0 or window >= len(S1):
        return 0  # Only returning profit

    df1 = pd.DataFrame({'y': S2, 'x': S1})

    # Apply Kalman filter regression
    state_means = KalmanFilterRegression(df1['x'], df1['y'])

    df1['hr'] = -state_means[:, 0]
    df1['bee'] = -state_means[:, 1]
    df1['spread'] = df1.y + (df1.x * df1['hr']) + df1['bee']

    # Rolling statistics for spread
    ma = df1.spread.rolling(window=window).mean()
    std = df1.spread.rolling(window=window).std()

    upper_band = ma + (k * std)
    lower_band = ma - (k * std)
    upper_band_soft = ma + (threshold * k * std)
    lower_band_soft = ma - (threshold * k * std)

    money = 0
    countS1 = 0
    countS2 = 0

    for i in range(len(df1)):
        if np.isnan(ma.iloc[i]) or np.isnan(std.iloc[i]):
            continue

        spread = df1.spread.iloc[i]

        # Trading logic (Short S1, Long S2)
        if spread > upper_band.iloc[i]:
            money += (S1.iloc[i] - S2.iloc[i])
            countS1 -= 1
            countS2 += S1.iloc[i] / (S2.iloc[i] + 1e-8)  # Avoid zero-division

        # Trading logic (Long S1, Short S2)
        elif spread < lower_band.iloc[i]:
            money -= (S1.iloc[i] - S2.iloc[i])
            countS1 += 1
            countS2 -= S1.iloc[i] / (S2.iloc[i] + 1e-8)

        # Close position when spread returns to mean
        elif lower_band_soft.iloc[i] <= spread <= upper_band_soft.iloc[i]:
            money += (S1.iloc[i] * countS1) + (S2.iloc[i] * countS2)
            countS1 = 0
            countS2 = 0

    return money  # Only return final money

def backtest(S1, S2, k, smol):
    all_profits = []  # Store cumulative profits
    start_dates = []  # Store corresponding start dates

    for start in range(len(S1) - smol + 1):  # Ensure valid range
        end = start + smol
        profit = trade(S1.iloc[start:end], S2.iloc[start:end], smol, k)  # Only returning money

        all_profits.append(profit)  # Store profit for this window
        start_dates.append(S1.index[end - 1])  # Store end date for tracking

    # Create DataFrame of results
    backtest_results = pd.DataFrame({'Date': start_dates, 'Profit': all_profits})
    backtest_results.set_index('Date', inplace=True)  # Set date as index

    return backtest_results

length_scores = [trade(df['ADBE'].iloc[:1057], df['MSFT'].iloc[:1057], l, k) for l in range(1, 255) for k in np.arange(0.6, 2, 0.2)]
best_length = np.argmax(length_scores) + 1  # Ensure non-zero window
print('Best window length:', best_length)

length_scores2 = [trade(df['ADBE'].iloc[:1057], df['MSFT'].iloc[:1057], l, k) for l in range(1, 255) for k in np.arange(0.6, 2, 0.2)]
best_length2 = np.argmax(length_scores2) + 1
print('Best test set window:', best_length2, 'Score:', length_scores2[best_length2 - 1])

backtest(df['ADBE'], df['MSFT'], 1, 632)